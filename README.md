# clone-tabnews

CriaÃ§Ã£o de um projeto clone do site TabNews com fins de estudos.

Este arquivo README terÃ¡ explicaÃ§Ãµes sobre o projeto em si, informaÃ§Ãµes de cada arquivo e sobre termos e padrÃµes utilizados. Tudo para registrar o conhecimento adquirido ao longo do desenvolvimento.

## ğŸ“‹ TÃ³picos

- [O que Ã© o projeto?](#O-que-Ã©-o-projeto)
- [Tecnologias](#Tecnologias)
- [ExplicaÃ§Ã£o de cada arquivo e pasta](#ExplicaÃ§Ã£o-de-cada-arquivo-e-pasta)
- [ExplicaÃ§Ã£o de termos, padrÃµes e nomes](#ExplicaÃ§Ã£o-geral)
- [Links](#Links)

## O que Ã© o projeto?

O projeto Ã© um clone do site jÃ¡ existente [TabNews](https://www.tabnews.com.br/). Aqui ele serÃ¡ montado do 0, atravÃ©s das aulas do [curso.dev](https://curso.dev/) do [Filipe Deschamps](https://github.com/filipedeschamps).

**Ao longo das aulas, irei adicionando explicaÃ§Ãµes sobre telas e funcionalidades.**

## Tecnologias

Atualmente estÃ¡ sendo usado:

- Next
- React
- Git e GitHub

**ExplicaÃ§Ãµes serÃ£o adicionadas a cada tecnologia no futuro.**

## ExplicaÃ§Ã£o de cada arquivo e pasta

Nessa seÃ§Ã£o vou explicar o que cada arquivo faz, como uma forma de registrar meu aprendizado e, conforme for estudando, complementar e alterar as informaÃ§Ãµes.

Cada seÃ§Ã£o deste tÃ³pico serÃ¡ dividida por pasta (que contÃ©m uma breve explicaÃ§Ã£o do que encontrar nela) e seus arquivos.

---

### ğŸ“‚ Pasta raiz

Pasta onde estÃ£o alguns arquivos de configuraÃ§Ã£o do projeto e as pastas que compoe todo o site. Abaixo a estrutura atual do projeto:

```
ğŸ“¦ root
â”£ ğŸ“‚ .github
â”ƒ â”— ğŸ“‚ workflows
â”ƒ    â”£ ğŸ“œ linting.yaml
â”ƒ    â”— ğŸ“œ tests.yaml
â”£ ğŸ“‚ .husky
â”ƒ  â”£ ğŸ“œ commit-msg
â”ƒ  â”— ğŸ“œ pre-commit
â”£ ğŸ“‚ infra
â”ƒ â”£ ğŸ“œ compose.yaml
â”ƒ â”£ ğŸ“œ database.js
â”ƒ â”£ ğŸ“‚ migrations
â”ƒ â”ƒ   â”— ğŸ“œ 1734553657446_test-migration
â”ƒ â”— ğŸ“‚ scripts
â”ƒ    â”£ ğŸ“œ cycle-of-webserver.js
â”ƒ    â”— ğŸ“œ wait-for-postgres.js
â”£ ğŸ“‚ pages
â”ƒ â”£ ğŸ“œ index.js
â”ƒ â”— ğŸ“‚ api
â”ƒ    â”— ğŸ“‚ v1
â”ƒ       â”£ ğŸ“‚ migrations
â”ƒ       â”ƒ  â”— ğŸ“œ index.js
â”ƒ       â”— ğŸ“‚ status
â”ƒ          â”— ğŸ“œ index.js
â”£ ğŸ“‚ tests
â”ƒ â”£ ğŸ“œ orchestrator.js
â”ƒ â”— ğŸ“‚ integration
â”ƒ    â”— ğŸ“‚ api
â”ƒ       â”— ğŸ“‚ v1
â”ƒ          â”£ ğŸ“‚ migrations
â”ƒ          â”ƒ  â”£ ğŸ“œ get.test.js
â”ƒ          â”ƒ  â”— ğŸ“œ post.test.js
â”ƒ          â”— ğŸ“‚ status
â”ƒ             â”— ğŸ“œ get.test.js
â”£ ğŸ“œ .editorconfig
â”£ ğŸ“œ .env.development
â”£ ğŸ“œ .eslintrc.json
â”£ ğŸ“œ .gitignore
â”£ ğŸ“œ .nvmrc
â”£ ğŸ“œ .prettierignore
â”£ ğŸ“œ .secretlintrc.json
â”£ ğŸ“œ commitlint.config.js
â”£ ğŸ“œ jest.config.js
â”£ ğŸ“œ jsconfig.js
â”£ ğŸ“œ LICENSE
â”£ ğŸ“œ package-lock.json
â”£ ğŸ“œ package.json
â”— ğŸ“œ README.md
```

#### ğŸ“œ .env.development

Arquivo usado para guardar as variÃ¡veis de ambiente do projeto, como valores para conexÃ£o do banco de dados, chaves API e portas. Este arquivo .env Ã© usado especificamente para o desenvolvimento do projeto.

#### ğŸ“œ .editorconfig

Arquivo usado para padronizar configuraÃ§Ãµes do editor de cÃ³digo em projetos, garantindo uma padronizaÃ§Ã£o entre diferentes colaboradores. Ele define regras como indentaÃ§Ã£o, uso de espaÃ§os ou tabs, codificaÃ§Ã£o de caracteres, etc. Essas configuraÃ§Ãµes podem ser aplicadas a todos os arquivos ou a diretÃ³rios especÃ­ficos, facilitando a manutenÃ§Ã£o do cÃ³digo.

#### ğŸ“œ .eslintrc.json

Arquivo com algumas configuraÃ§Ãµes que vocÃª pode mexer do Eslint, uma ferramenta para anÃ¡lise estÃ¡tica de cÃ³digo que ajuda a identificar e corrigir problemas no cÃ³digo JavaScript. Por exemplo, com ele Ã© possÃ­vel extender algumas configuraÃ§Ãµes extras, plugins, definir regras personalizadas.

#### ğŸ“œ .gitignore

O arquivo .gitignore Ã© usado para informar ao Git quais arquivos ou pastas devem ser ignorados no versionamento. Isso significa que o Git nÃ£o rastrearÃ¡ nem incluirÃ¡ esses itens em commits, como se eles nÃ£o existissem para ele. Dessa forma, Ã© possÃ­vel proteger informaÃ§Ãµes sensÃ­veis, e evitar o registro de arquivos gerados automaticamente, no nosso caso, as pastas node_modules e .next.

#### ğŸ“œ .nvmrc

Arquivo responsÃ¡vel por armazenar a versÃ£o do Node utilizado no projeto. Nele contÃ©m escrito `lts/hydrogen` (a versÃ£o que estamos usando), e ele estÃ¡ aqui para definir qual Ã© a versÃ£o padrÃ£o utilizada no nosso projeto, ou seja, sempre que for executado `nvm install`, ele pegarÃ¡ o que estÃ¡ definido em `.nvmrc` e utilizarÃ¡ para instalaÃ§Ã£o da versÃ£o.

- Curiosidade: este tipo de arquivo Ã© um arquivo de "run commands", e para identificar esse tipo de arquivo, veja se ele possui "**rc**" no final dele. Esses arquivos sÃ£o executados automaticamente quando o programa inicia, e geralmente contÃ©m configuraÃ§Ãµes e comandos.

#### ğŸ“œ .prettierignore

Arquivo usado para instruir o Prettier sobre quais arquivos ou diretÃ³rios devem ser ignorados durante a aplicaÃ§Ã£o de regras de formataÃ§Ã£o. (A partir da versÃ£o 3.0.0, o prÃ³prio Prettier ignora o que estÃ¡ no .gitignore, mas deixei aqui para demonstrar uma soluÃ§Ã£o para versÃµes mais antigas).

#### ğŸ“œ .secretlint.json

Ã‰ o arquivo de configuraÃ§Ã£o do Secretlint, uma ferramenta que ajuda a identificar e prevenir a exposiÃ§Ã£o de segredos (como senhas, chaves de API e outros dados sensÃ­veis) no cÃ³digo-fonte, ele atualmente define as regras a serem usadas pelo mÃ³dulo.

#### ğŸ“œ commitlint.config.js

Ã‰ onde fica a configuraÃ§Ã£o do mÃ³dulo "Commitlint", que tem como objetivo garantir que as mensagens de commit sigam um formato e estilo padronizados. Por enquanto, ele serve para mostrar ao mÃ³dulo qual "modelo de configuraÃ§Ã£o" do mÃ³dulo usar (ele possui vÃ¡rias configuraÃ§Ãµes que podem ser exportadas).

#### ğŸ“œ jest.config.js

Um arquivo de configuraÃ§Ãµes para o jest, onde nele definimos algumas configuraÃ§Ãµes para os testes. Podemos definir, por exemplo, o diretorio raiz de testes, qual arquivo .env deve ser usado e habilitar o uso de sintaxes modernas como ESM (ECMAScript Modules).

#### ğŸ“œ jsconfig.js

Arquivo que define configuraÃ§Ãµes para o uso de JavaScript no projeto. Atualmente, ele define a URL base do projeto.

#### ğŸ“œ LICENSE

Ã‰ o arquivo de licenÃ§a do projeto. Atualmente a licenÃ§a Ã© o MIT. Isso significa que qualquer pessoa pode usar, modificar e distribuir o software, desde que inclua a licenÃ§a original e o aviso de copyright (ou seja, vocÃª pode mexer nele ğŸ˜Š).

#### ğŸ“œ package.json

Arquivo que contÃ©m metadados de um projeto node, como nome, autor, descriÃ§Ã£o, licenÃ§a, scripts do projeto, etc. Mas uma das principais funÃ§Ãµes dele Ã© listar as dependencias do sistema, assim, quando for preciso instalar o que Ã© preciso para tudo funcionar, Ã© o package.json que assegura que todas as libs/mÃ³dulos necessÃ¡rias serÃ£o instaladas.

#### ğŸ“œ package-lock.json

Este Ã© responsÃ¡vel por manter todas as dependÃªncias e subdependÃªncias na respectiva versÃ£o e configuraÃ§Ã£o definida pelo dev, assim garantindo que a versÃ£o vai ser igual independente do ambiente onde estÃ¡ sendo desenvolvida. Dessa forma, ele evita problemas de incompatibilidade e evita que os pacotes atualizem inesperadamente.

#### ğŸ“œ README.md

Este arquivo do tipo markdown geralmente serve para documentar as informaÃ§Ãµes essenciais do sistema, como descriÃ§Ãµes das funcionalidades, instruÃ§Ãµes de instalaÃ§Ã£o, requisitos e exemplos de uso. Se um usuÃ¡rio quer conhecer o projeto, Ã© o primeiro lugar que ele deve acessar.

PorÃ©m, neste projeto estou utilizando o README.md tambÃ©m para anotaÃ§Ãµes e explicaÃ§Ãµes do que estÃ¡ sendo usado no desenvolvimento, a fim de ter um lugar organizado para consulta posterior.

---

### ğŸ“‚ .github

DiretÃ³rio especial de arquivos de configuraÃ§Ã£o relacionados a funcionalidades extras do GitHub.

### ğŸ“‚ .github/workflows

ResponsÃ¡vel por guardar os workflows do GitHub Actions. Workflows sÃ£o automaÃ§Ãµes que podem ser executadas em resposta a eventos no repositÃ³rio (por exemplo, ao fazer um pull request).

#### ğŸ“œ .github/workflows/**linting.yaml**

Ã‰ um workflow que serÃ¡ executado durante o pull request, ele tem como objetivo verificar se a formataÃ§Ã£o padrÃ£o de cÃ³digo e commits estÃ¡ correta, assim como se o cÃ³digo estÃ¡ limpo (limpo de acordo com as definiÃ§Ãµes do ESLINT, como por exemplo, nÃ£o ter variÃ¡veis sem uso/atribuiÃ§Ã£o no cÃ³digo).

#### ğŸ“œ .github/workflows/**tests.yaml**

Ã‰ um workflow que serÃ¡ executado durante o pull request, ele tem como objetivo rodar os testes automatizados do projeto e ver se nÃ£o ocorre nenhum erro de execuÃ§Ã£o.

---

### ğŸ“‚ .husky

DiretÃ³rio onde fica configurado o husky (este que estÃ¡ numa pasta ignorada pelo git) e os arquivos a serem executados por ele. Husky Ã© uma ferramenta usada para definir e executar scripts durante o processo de interaÃ§Ã£o com o Git, atualmente usamos para executar comandos durante o processo de commit.

#### ğŸ“œ .husky/**commit-msg**

Ã‰ um arquivo que contÃªm o comando que vai ser rodado apÃ³s a criaÃ§Ã£o de uma mensagem de commit. O comando em si verifica se a mensagem do commit estÃ¡ seguindo o padrÃ£o definido.

#### ğŸ“œ .husky/**pre-commit**

Ã‰ um arquivo que contÃªm o comando que vai ser executado logo antes do commit ser feito, ou seja, na primeira etapa do processo de commit (antes mesmo do `.husky/commit-msg`). O comando em si escrito nele verifica se existem "secrets" escritos em algum arquivo do commit, mas num geral, serve para vÃ¡rias verificaÃ§Ãµes de prÃ©-processamento.

---

### ğŸ“‚ Infra

Pasta responsÃ¡vel por guardar arquivos sobre a infraestrutura do projeto. Por exemplo, arquivos sobre o database, containers e outros serviÃ§os.

#### ğŸ“œ Infra/**compose.yaml**

Um arquivo responsÃ¡vel por configurar os serviÃ§os do Docker. No momento, ele contÃªm a configuraÃ§Ã£o do banco de dados, com sua imagem, variÃ¡veis de ambiente e portas definidas.

#### ğŸ“œ Infra/**database.js**

Arquivo responsÃ¡vel por gerenciar a conexÃ£o com o banco de dados e realizar consultas. Utilizamos o mÃ³dulo 'pg' para conexÃ£o (mÃ³dulo de conexÃ£o para SGBD Postgres).

#### ğŸ“‚ infra/**migrations**

DiretÃ³rio responsÃ¡vel por guardar as migrations do nosso projeto. Migrations sÃ£o scripts responsÃ¡veis por manusear e versionar alteraÃ§Ãµes (exemplo :criaÃ§Ã£o, exclusÃ£o e modificaÃ§Ã£o de tabelas) no nosso banco de dados via cÃ³digo, evitando a utilizaÃ§Ã£o de meios manuais de alteraÃ§Ã£o.

#### ğŸ“œ infra/migrations/**1734553657446_test-migration**

Arquivo de uma migration de teste. Atualmente nÃ£o levanta nenhuma alteraÃ§Ã£o no banco de dados, sendo usado apenas como experimento para validaÃ§Ã£o do fluxo de migrations.

#### ğŸ“‚ infra/**scripts**

Pasta que mantem os scripts utilizados na infraestrutura do projeto, oferecendo suporte a operaÃ§Ãµes crÃ­ticas e automaÃ§Ãµes necessÃ¡rias para o funcionamento correto dos serviÃ§os.

#### ğŸ“œ infra/scripts/**wait-for-postgres.js**

Arquivo que executa uma funÃ§Ã£o para garantir que o PostgreSQL esteja pronto para uso antes que outras operaÃ§Ãµes dependentes sejam realizadas. Este script Ã© usado para que problemas de "race conditions" que envolvam o postgres nÃ£o aconteÃ§am (ex: as migrations serem executadas antes do postgres inicializar).

#### ğŸ“œ infra/scripts/**cycle-of-webserver.js**

Arquivo que executa um mÃ©todo responsÃ¡vel por inicializar o servidor local, e quando for encerrado, exterminar todos os serviÃ§os que iniciaram junto com ele. Ele Ã© executado no comando "npm run dev".

---

### ğŸ“‚ Pages

Ã‰ a pasta onde ficarÃ¡ todas as pÃ¡ginas do site, e ela define automaticamente que, qualquer arquivo JS/TS aqui, Ã© uma pÃ¡gina (com rota URL).

#### ğŸ“œ pages/**index.js**

Ã‰ a pÃ¡gina inicial do projeto, tem esse nome pois, por convenÃ§Ã£o, toda pÃ¡gina inicial se chama index (isso vem de antigamente, onde os websites possuiam uma pÃ¡gina que recebia o usuÃ¡rio contendo links para o restante das pÃ¡ginas).

#### ğŸ“‚ pages/**api**

Uma subpasta de pages, Ã© responsÃ¡vel por guardar as pÃ¡ginas/rotas referentes a API do sistema, contendo nela subpastas de cada versÃ£o.

#### ğŸ“‚ pages/api/**v1**

Ã‰ a pasta da versÃ£o 1.0 da API do sistema. Mantem todas as rotas da API da versÃ£o referente.

#### ğŸ“‚ pages/api/v1/**migrations**

Guarda o que Ã© preciso para a rota [/api/v1/migrations]().

#### ğŸ“‚ pages/api/v1/migrations/**index.js**

ContÃªm as formas de retorno de cada solicitaÃ§Ã£o HTTP. Com retornos GET e POST, a requsiÃ§Ã£o GET retorna as migrations pendentes do projeto; a requisiÃ§Ã£o POST executa as migrations pendentes e retorna quais foram executadas.

#### ğŸ“‚ pages/api/v1/**status**

Guarda o que Ã© preciso para a rota [/api/v1/status]().

#### ğŸ“‚ pages/api/v1/status/**index.js**

ContÃªm as formas de retorno de cada solicitaÃ§Ã£o HTTP. Com apenas requisiÃ§Ã£o GET, a estrutura retornada Ã© um json com dados do status do database.

### ğŸ“‚ Tests

Ã‰ a pasta que armazena todos os testes automatizados do projeto. A estrutura de pastas dos testes reflete a estrutura dos arquivos testados. Para evitar redundÃ¢ncia, apenas os arquivos de teste sÃ£o descritos.

Exemplo destacando os caminhos semelhantes:

```
â”£ ğŸ“‚ pages
â”ƒ â”— ğŸ“‚ api --> Caminhos semelhantes
â”ƒ    â”— ğŸ“‚ v1
â”ƒ       â”— ğŸ“‚ status
â”ƒ          â”— ğŸ“œ index.js ----> arquivo que tem o que vai ser testado
â”£ ğŸ“‚ tests
â”ƒ â”— ğŸ“‚ integration
â”ƒ    â”— ğŸ“‚ api --> Caminhos semelhantes
â”ƒ       â”— ğŸ“‚ v1
â”ƒ          â”— ğŸ“‚ status
â”ƒ             â”— ğŸ“œ get.test.js ----> arquivo de teste
```

#### ğŸ“œ tests/**orchestrator.js**

Arquivo que tem como objetivo garantir que todos os serviÃ§os necessÃ¡rios de sua responsabilidade estarÃ£o disponÃ­veis para os comandos subsequentes. Ele garante atravÃ©s da espera do funcionamento do serviÃ§o (atualmente sendo o web server).

#### ğŸ“‚ tests/**integration**

ResponsÃ¡vel por guardar todos os testes que sÃ£o **testes de integraÃ§Ã£o** (testes que verificam como diferentes partes do sistema funcionam em conjunto).

#### ğŸ“œ tests/integration/api/v1/migrations/**get.test.js**

Arquivo de teste responsÃ¡vel por testar a requisiÃ§Ã£o GET da rota [/api/v1/migrations](). Nela testa se a requisiÃ§Ã£o volta com o status code 200 e se seu corpo retorna um array que nÃ£o esteja vazio.

#### ğŸ“œ tests/integration/api/v1/migrations/**post.test.js**

Testa a requisiÃ§Ã£o POST da rota [/api/v1/migrations](). Nela testa duas requisiÃ§Ãµes POST em sequÃªncia: na primeira, a requisiÃ§Ã£o deve retornar com o status code 201 e o seu corpo deve devolver um array que nÃ£o esteja vazio; na segunda requisiÃ§Ã£o, ela deve retornar com o status code 200 e o corpo deve devolver um array que esteja vazio.

#### ğŸ“œ tests/integration/api/v1/status/**get.test.js**

Este Ã© o arquivo de teste responsÃ¡vel por testar a requisiÃ§Ã£o GET da rota [/api/v1/status](). Nela testa se a requisiÃ§Ã£o volta com o status code 200 e se suas informaÃ§Ãµes estÃ£o coerentes.

## ExplicaÃ§Ã£o geral

### Protocolos

SÃ£o convenÃ§Ãµes que sÃ£o utilizadas entre cliente-servidor na web para garantir a melhor forma de passar informaÃ§Ã£o entre os lados. Os protocolos podem ser utilizados juntos, como se fosse camadas.
Esses tendem a seguir o modelo OSI ou TCP/IP, que possuem camadas para cada funÃ§Ã£o.

- Exemplo: HTTP (define como as informaÃ§Ãµes vÃ£o ser trocadas) > TCP (transmite as informaÃ§Ãµes de forma confiÃ¡vel) > IP (encaminha os dados pela rede)

#### HTTP

HyperText Transfer Protocol: protocolo que Ã© usado para transferÃªncia de arquivos "hypertext" (arquivos que fazem referÃªncia a outros documentos)

- Curiosidade: hoje em dia o HTTP em si nÃ£o Ã© tÃ£o seguro, por isso, foi se criado o HTTPS, que Ã© uma versÃ£o que utiliza o protocolo SSL/TLS para criptografia, o que permite uma seguranÃ§a superior ao HTTP.

#### FTP

File Transfer Protocol: protocolo para transferÃªncias de arquivos. Geralmente usado em servidores e websites.

#### SMTP

Simple Mail Transfer Protocol: protocolo para transferÃªncias de mensagens de e-mail.

#### TCP (Transmission Control Protocol)

Protocolo que prioriza a confiabilidade dos dados transmitidos, mesmo que isso reduza a velocidade, garantindo que todos os dados chegam ao destino sem perdas. Ele faz a verificaÃ§Ã£o de cada pacote, observando se eles estÃ£o na ordem correta, com todo o conteÃºdo que foi passado.

#### UDP (User Datagram Protocol)

Protocolo que oferece uma transmissÃ£o mais rÃ¡pida que o TCP, mas sem garantia de entrega de todos os pacotes, o que permite perdas. Ele nÃ£o possui verificaÃ§Ã£o dos pacotes, e por esse motivo que ele Ã© mais rÃ¡pido (e menos Ã­ntegro).

#### Onde usar TCP ou UDP?

| Protocolo | Uso                                                       | Exemplos                          |
| --------- | --------------------------------------------------------- | --------------------------------- |
| TCP       | Pacotes enviados totalmente, sem perda e na ordem correta | Mensagens, arquivos               |
| UDP       | Pacotes nÃ£o precisam chegar na Ã­ntegra                    | Chamadas em vÃ­deo, jogos digitais |

**Curiosidade:** O lag ocorre por causa da perda de pacotes e da forma como o UDP ignora esse problema.

Resumindo: TCP: mais confiabilidade, menos velocidade, UDP: mais velocidade, menos confiabilidade.

#### IP (Internet Protocol)

Protocolo responsÃ¡vel por direcionar, encaminhar e rotear os pacotes de dados para o destino correto atravÃ©s da rede.
Geralmente usado com o TCP, formando o protocolo TCP/IP.

---

#### DNS

O DNS (Domain Name System) Ã© um sistema que traduz nomes de domÃ­nio legÃ­veis por humanos (como o tabnews.com.br) em endereÃ§os IP numÃ©ricos, que sÃ£o lidos pelos computadores para localizar servidores e serviÃ§os na internet. Ele funciona como uma espÃ©cie de "lista telefÃ´nica da internet", permitindo que vocÃª acesse sites digitando nomes, ao invÃ©s de longas sequÃªncias numÃ©ricas.

#### File-based Routing

Ã‰ uma forma de definir as rotas do projeto, onde cada arquivo dentro de uma pasta (no nosso caso atual, a pages) se torna uma rota, ou seja, a estrutura do diretÃ³rio "pages" Ã© a estrutura das URLs de cada pÃ¡gina do site. Dessa forma nÃ£o Ã© necessÃ¡rio criar cada rota manualmente em algum arquivo.

- Obs.: existe uma outro diretÃ³rio que pode ser usado para o mesmo fim, chamado de "app".

#### RelaÃ§Ã£o Client/Server

A relaÃ§Ã£o Client/Server Ã© uma forma de descrever a interaÃ§Ã£o entre um cliente (que faz uma solicitaÃ§Ã£o), e um servidor (que processa essa solicitaÃ§Ã£o e retorna uma resposta).

Segue um exemplo:
Um usuÃ¡rio acessa o site do TabNews e clica no botÃ£o para comentar em um post. Como o usuÃ¡rio nÃ£o estÃ¡ logado, o site exibe uma tela de login.

O que aconteceu?
O usuÃ¡rio atuou como o cliente da relaÃ§Ã£o, requisitando a funcionalidade de comentar no post. O site, funcionando como o servidor, processou essa solicitaÃ§Ã£o, viu que ele nÃ£o estava na conta e respondeu envinado a tela de login.

#### Hospedagem e Deploy

Hospedagem Ã© o processo de colocar o sistema em um servidor, fazendo com que ele esteja disponÃ­vel na internet para que os usuÃ¡rios possam acessÃ¡-lo a qualquer momento. Ao hospedar, seus arquivos irÃ£o para um computador especializado em manter o sistema online.

Deploy Ã© sobre o processo de colocar o que foi desenvolvido localmente no ambiente de produÃ§Ã£o. Existem deploys que podem ser configurados para serem automatizados, por exemplo, com integraÃ§Ã£o contÃ­nua, que ajudam a garantir que as atualizaÃ§Ãµes sejam implementadas eficientemente.

#### Continuous Integration (CI)

Continuous Integration (ou IntegraÃ§Ã£o ContÃ­nua) Ã© uma prÃ¡tica no desenvolvimento de software que envolve a integraÃ§Ã£o frequente do cÃ³digo de diferentes desenvolvedores em um repositÃ³rio compartilhado. Toda vez que uma mudanÃ§a Ã© feita no cÃ³digo, um sistema automatizado verifica se tudo estÃ¡ funcionando corretamente.

---

### Milestones e Issues

SÃ£o algumas formas que estamos organizando a produÃ§Ã£o do projeto.

#### Milestones

SÃ£o marcos importantes no planejamento do projeto, usados para organizar o progresso em etapas maiores ou metas principais. Elas permitem acompanhar o andamento e verificar se os objetivos gerais estÃ£o sendo atingidos. Cada milestone pode agrupar vÃ¡rias issues.

#### Issues

SÃ£o tarefas especÃ­ficas ou problemas do projeto que precisam ser resolvidos. Representam etapas menores com mais detalhes, servindo como componentes das milestones. Issues podem incluir correÃ§Ãµes de bugs, desenvolvimento de novas funcionalidades ou tarefas organizacionais.

---

#### LTS

LTS, ou Long Term Support (Suporte de Longo Prazo), sÃ£o versÃµes de software que os desenvolvedores da plataforma garantem que terÃ£o um suporte de longo prazo, ou seja, os cÃ³digos desenvolvidos com versÃµes "LTS" recebem patches de correÃ§Ã£o/seguranÃ§a e suporte atualizados durante um longo tempo. Esse tipo de versÃ£o Ã© Ãºtil para criar projetos mais estÃ¡veis, por isso, utilizamos o **LTS hydrogen** no sistema.

#### Endpoint

Ã‰ o local final que uma requisiÃ§Ã£o HTTP chega, tambÃ©m Ã© usado para descrever um endereÃ§o de API.

#### Serverless

Ã‰ um modelo de computaÃ§Ã£o em nuvem onde, o responsÃ¡vel por configurar, escalar e gerenciar o servidor fica com o provedor. Ou seja, nÃ³s devs apenas tÃªm o objetivo de codificar o sistema, enquanto o provedor (Vercel) cuida desse processo por trÃ¡s.

#### YAML

YAML significa "Yet Another Markup Language", mas atualmente pode ser entendido como: "YAML Ain't Markup Language". Ã‰ usado para armazenar dados, porÃ©m de forma mais simples para humanos, e Ã© usado em vÃ¡rios serviÃ§os, um exemplo seria o Docker.

## Links

Alguns links que usei para estudar ou complementar este arquivo (ou que nÃ£o foram temas abordados diretamente no curso.dev).

#### Protocolos

- [Protocolos no geral](https://www.hostmidia.com.br/blog/protocolos-de-internet/)
- [Modelo OSI e TCP/IP](https://www.azion.com/pt-br/blog/modelo-osi-modelo-tcp-ip-importancia-dos-padroes-para-redes-e-internet/)
- [UDP vs TCP](https://youtu.be/ZEEBsq3eQmg)

#### Serverless

- [ExplicaÃ§Ã£o](https://www.redhat.com/pt-br/topics/cloud-native-apps/what-is-serverless)
- [ExplicaÃ§Ã£o 2 (obs: apenas alunos do curso.dev conseguem acessar este link)](https://curso.dev/alunos/Andrei/b49e8662-5d37-4132-b481-c09c2157dcd7)
